<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/gui/Tree.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/gui/Tree.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
(function() {

'use strict';

var avu = Autodesk.Viewing.UI,
    avp = Autodesk.Viewing.Private;

/**
 * Tree view control delegate
 * This class allows you to customize the behavior of a Tree view control.
 * Override the methods you want and pass an instance of this class to
 * the Tree constructor.
 * @constructor
 */
var TreeDelegate = function () {
};

TreeDelegate.prototype.constructor = TreeDelegate;

/**
 * Override this method to specify whether or not a node is a group node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if this node is a group node, false otherwise
 */
TreeDelegate.prototype.isTreeNodeGroup = function (node) {
    throw 'isTreeNodeGroup is not implemented.';
};

/**
 * Override this method to specify the id for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Id of the tree node
 */
TreeDelegate.prototype.getTreeNodeId = function (node) {
    throw 'getTreeNodeId is not implemented.';
};

/**
 * Override this method to specify the label for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Label of the tree node
 */
TreeDelegate.prototype.getTreeNodeLabel = function (node) {
    return node.name;
};

/**
 * Override this method to specify if a tree node should be created for this node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if a node should be created, false otherwise
 */
TreeDelegate.prototype.shouldCreateTreeNode = function (node) {
    return true;
};


/**
 * Iterates over the children of a given node and calls the callback with each child.
 */
TreeDelegate.prototype.forEachChild = function (node, callback) {
    var childCount = node.children ? node.children.length : 0;
    for (var childIndex = 0; childIndex &lt; childCount; ++childIndex) {
        var child = node.children[childIndex];
        callback(child);
    }
};


/**
 * Override this to create the HTMLContent for this node for appending to the
 * parent.  By default, a label is created.
 *
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parent - the parent for this content.
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 *
 * @private
 */
TreeDelegate.prototype.createTreeNode = function (node, parent, options) {
    var label = document.createElement('label');
    parent.appendChild(label);

    var text = this.getTreeNodeLabel(node);
    if (options &amp;&amp; options.localize) {
        label.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }
    label.textContent = text;
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeClick = function (tree, node, event) {};

/**
 * Override this to do something when the user clicks on this tree node's icon.
 * The default behavior is for the icons for group nodes to toggle the collapse/expand
 * state of that group.
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeIconClick = function (tree, node, event) {
    if (tree.delegate().isTreeNodeGroup(node)) {
        tree.setCollapsed(node, !tree.isCollapsed(node));
    }
};

/**
 * Override this to do something when the user double-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeDoubleClick = function (tree, node, event) {};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeRightClick = function (tree, node, event) {};


/**
 * Override this to specify the type of a node. This way, in css, the designer
 * can specify custom styling per type.
 * @param {Object} node - Node in the model Document
 * @returns {string} Class for the node
 */
TreeDelegate.prototype.getTreeNodeClass = function (node) {
    return '';
};

/**
 * Override this method to do something when the user hovers on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
*/
TreeDelegate.prototype.onTreeNodeHover = function (tree, node, event) {};

/**
 * Tree view control
 * @constructor
 * @param {TreeDelegate} delegate
 * @param {Object} root - A node in the model Document
 * @param {HTMLElement|string} parentContainer - Or parentContainerId
 * @param {Object} options
 */
var Tree = function (delegate, root, parentContainer, options) {
    this.myDelegate = delegate;
    this.mySelectedNodes = [];
    this.myOptions = options || {};

    var className = 'treeview';

    this.myGroupNodes = []; // &lt;group> HTML elements in the tree

    this.nodeToElement = {};
    this.nodeIdToNode = {};

    var rootContainer = this.myRootContainer = this.createHtmlElement_(parentContainer, 'div', className);

    var rootElem = this.rootElem = this.createElement_(root, rootContainer, options, 0);

    this.setInputHandlers_();

    if(options &amp;&amp; options.excludeRoot) {
        rootElem.classList.add("exclude");
    }

};

Tree.prototype.constructor = Tree;

/**
 * Show/hide the tree control
 * @param {boolean} show - true to show the tree control, false to hide it
 */
Tree.prototype.show = function (show) {
    var rootContainer = this.myRootContainer;
    if (show) {
        rootContainer.style.display = 'block'; // TODO: want fade in
    } else {
        rootContainer.style.display = 'none';
    }
};

/**
 * Get the root container
 * @nosideeffects
 * @returns {string}
 */
Tree.prototype.getRootContainer = function () {
    return this.myRootContainer;
};

/**
 * Get DOM element for a given logical tree node (or its integer id)
 * @nosideeffects
 * @returns {HTMLElement}
 */
Tree.prototype.getElementForNode = function (node) {

    //TODO: Remove this section once all places that hit it are gone
    if (typeof node !== "number" &amp;&amp; typeof node !== "string") {
        //console.warn("Node object used where node ID should have");
        node = this.myDelegate.getTreeNodeId(node);
    }

    return this.nodeToElement[node];
};

/**
 * Get the tree delegate
 * @nosideeffects
 * @returns {TreeDelegate}
 */
Tree.prototype.delegate = function () {
    return this.myDelegate;
};

/**
 * Is the given group node in the tree collapsed?
 * @nosideeffects
 * @param {Object} group -The group node
 * @returns {boolean} true if group node is collapsed, false if expanded
 */
Tree.prototype.isCollapsed = function (group) {
    return this.hasClass(group, 'collapsed');
};

/**
 * Collapse/expand the given group node in the tree
 * @param {Object} group - the group node
 * @param {boolean} collapsed - true to collapse the group node, false to expand it
 */
Tree.prototype.setCollapsed = function (group, collapsed, recursive) {
    if (collapsed) {
        this.addClass(group, 'collapsed', recursive);
        this.removeClass(group, 'expanded', recursive);
    } else {
        this.addClass(group, 'expanded', recursive);
        this.removeClass(group, 'collapsed', recursive);
    }
};

/**
 * Collapse/expand all group nodes in the tree
 * @param {boolean} collapsed - true to collapse tree, false to expand it
 */
Tree.prototype.setAllCollapsed = function (collapsed) {
    var wantNode, changeNode;

    if (collapsed) {
        wantNode = function (node) {
            return node.classList.contains('expanded');
        };
        changeNode = function (node) {
            node.classList.add('collapsed');
            node.classList.remove('expanded');
        };

    } else {
        wantNode = function (node) {
            return node.classList.contains('collapsed');
        };
        changeNode = function (node) {
            node.classList.add('expanded');
            node.classList.remove('collapsed');
        };
    }

    for (var i = 0; i &lt; this.myGroupNodes.length; ++i) {
        var node = this.myGroupNodes[i];
        if (wantNode(node)) {
            changeNode(node);
        }
    }
};

/**
 * Add the given nodes to the current selection
 * @param {Array.&lt;Object>} nodes - nodes to add to the current selection
 */
Tree.prototype.addToSelection = function (nodes) {
    var tree = this;

    function addSingle(node) {
        var index = tree.mySelectedNodes.indexOf(node);
        if (index === -1) {
            tree.mySelectedNodes.push(node);
            return true;
        }
        return false;
    }

    var numNodes = nodes.length;
    for (var i = 0; i &lt; numNodes; ++i) {
        var node = nodes[i];
        if (addSingle(node)) {
            this.addClass(node, 'selected');
        }
    }
};

/**
 * Remove the given nodes from the current selection
 * @param {Array.&lt;Object>} nodes - The nodes to remove from the current selection
 */
Tree.prototype.removeFromSelection = function (nodes) {
    var tree = this;

    function removeSingle(node) {
        var index = tree.mySelectedNodes.indexOf(node);
        if (index !== -1) {
            tree.mySelectedNodes.splice(index, 1);
            return true;
        }
        return false;
    }

    for (var i = nodes.length - 1; i >= 0; --i) {
        var node = nodes[i];
        if (removeSingle(node)) {
            this.removeClass(node, 'selected');
        }
    }
};

/**
 * Set the current selection
 * @param {Array.&lt;Object>} nodes - nodes to make currently selected
 */
Tree.prototype.setSelection = function (nodes) {
    this.removeFromSelection(this.mySelectedNodes);
    this.addToSelection(nodes);
    return this.mySelectedNodes;
};

/**
 * Clear the current selection
 */
Tree.prototype.clearSelection = function () {
    this.removeFromSelection(this.mySelectedNodes);
};

/**
 * Is the given node selected?
 * @nosideeffects
 * @param {Object} node - The tree node
 * @returns {boolean} - true if node is selected, false otherwise
 */
Tree.prototype.isSelected = function (node) {
    return this.hasClass(node, 'selected');
};

Tree.prototype.scrollTo = function (node) {
    var elem = this.getElementForNode(node);

    if (elem) {
        var total = elem.offsetTop;
        elem = elem.parentNode;
        while (elem &amp;&amp; elem != this.myRootContainer) {
            total += elem.offsetTop;
            elem = elem.parentNode;
        }

        this.myRootContainer.parentNode.scrollTop = total;
    }
};


/**
 * Add a class to a node
 * @param {Number|Object} node - The tree node
 * @param {string} className
 * @returns {boolean} - true if the class was added, false otherwise
 */
Tree.prototype.addClass = function (node, className, recursive) {

    var elem = this.getElementForNode(node);
    if (elem) {

        if (recursive) {
            //It is intentional that the recursive add starts at the parent.
            elem = elem.parentNode;
            var top = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer;
            while (elem &amp;&amp; elem !== top) {
                elem.classList.add(className);
                elem = elem.parentNode;
            }
        } else {
            elem.classList.add(className);
        }

        return true;
    }

    return false;
};

/**
 * Remove a class from a node
 * @param {Number|Object} node - The tree node or its dbId
 * @param {string} className
 * @returns {boolean} - true if the class was removed, false otherwise
 */
Tree.prototype.removeClass = function (node, className, recursive) {
    var elem = this.getElementForNode(node);
    if (elem) {

        if (recursive) {
            //It is intentional that the recursive add starts at the parent.
            elem = elem.parentNode;
            var top = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer;
            while (elem &amp;&amp; elem !== top) {
                elem.classList.remove(className);
                elem = elem.parentNode;
            }
        } else {
            elem.classList.remove(className);
        }

        return true;
    }

    return false;
};

/**
 * Does the node have the given class?
 * @nosideeffects
 * @param {Number|Object} node - The node or its dbId
 * @param {string} className
 * @returns {boolean} true if the node has the given class, false otherwise
 */
Tree.prototype.hasClass = function (node, className) {
    return this.getElementForNode(node).classList.contains(className);
};


/**
 * Clears the contents of the tree
 */
Tree.prototype.clear = function () {

    var rootContainer = this.myRootContainer;
    while (rootContainer.hasChildNodes()) {
        rootContainer.removeChild(rootContainer.lastChild);
    }

    this.nodeToElement = {};
    this.nodeIdToNode = {};
};

/**
 * Given a node, create the corresponding HTML elements for the node and all of its descendants
 * @private
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parentElement
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 * @param {Number} [depth]
 */
Tree.prototype.createElement_ = function (node, parentElement, options, depth) {
    if (!node) {
        return null;
    }

    if (!this.myDelegate.shouldCreateTreeNode(node)) {
        return null;
    }

    var tree = this;
    var elem;

    function createElementForNode(parentElement, type, classes, theNode) {
        var root = tree.createHtmlElement_(parentElement, type, classes);
        var nodeId = tree.myDelegate.getTreeNodeId(theNode);
        root.setAttribute("lmv-nodeId", nodeId);

        var header = tree.createHtmlElement_(root, 'header');
        var icon = tree.createHtmlElement_(header, 'icon');

        icon.addEventListener('click', function (e) {
            tree.myDelegate.onTreeNodeIconClick(tree, node, e);
            e.stopPropagation();
            e.preventDefault();
        }, false);

        tree.myDelegate.createTreeNode(node, header, options);
        return root;
    }

    var nodeId = this.myDelegate.getTreeNodeId(node);

    if (tree.myDelegate.isTreeNodeGroup(node)) {
        elem = createElementForNode(parentElement, 'group', 'expanded', node);
        tree.nodeToElement[nodeId] = elem;
        tree.nodeIdToNode[nodeId] = node;

        var whichDepth = tree.myOptions.excludeRoot ? 1 : 0;

        if (depth == whichDepth)
            elem.style.left = "0px";

        // Remember this group node for use by setAllCollapsed().
        //
        tree.myGroupNodes.push(elem);

        tree.myDelegate.forEachChild(node, function(child) {
            tree.createElement_(child, elem, options, depth+1);
        });

    } else {
        elem = createElementForNode(parentElement, 'leaf', 'expanded', node);
        tree.nodeToElement[nodeId] = elem;
        tree.nodeIdToNode[nodeId] = node;

        var whichDepth = tree.myOptions.excludeRoot ? 1 : 0;

        if (depth == whichDepth)
            elem.style.marginLeft = "0px";
    }

    var c = tree.myDelegate.getTreeNodeClass(node);
    if (c) {
        elem.classList.add(c);
    }

    return elem;
};

Tree.prototype.setInputHandlers_ = function() {

    var tree = this;
    var rootElem = this.myRootContainer;

    var NODE_NOT_FOUND = null;
    var getNodeFromElement = function(eventTarget) {
        var ret = null;
        var found = false;
        do {
            if (!eventTarget || eventTarget === rootElem) {
                ret = null;
                found = true;  // not found
            } else if (eventTarget.hasAttribute("lmv-nodeId")) {
                ret = eventTarget;
                found = true;
            } else {
                eventTarget = eventTarget.parentElement;
            }
        } while(!found);

        if (ret) {
            var nodeId = ret.getAttribute("lmv-nodeId");
            return tree.nodeIdToNode[nodeId] || NODE_NOT_FOUND;
        }
        return NODE_NOT_FOUND;
    };

    if (isTouchDevice()) {
        this.hammer = new Hammer.Manager(rootElem, {
            recognizers: [
                [Hammer.Tap, {event: 'doubletap', taps: 2, interval: 400, threshold: 6, posThreshold: 30}],
                [Hammer.Press, { event: 'press', time: 500 } ]
            ],
            inputClass: Hammer.TouchInput
        });
        this.hammer.on("doubletap", function (event) {
            var node = getNodeFromElement(event.target);
            if (node === NODE_NOT_FOUND) return;
            tree.myDelegate.onTreeNodeDoubleClick(tree, node, event);
        });

        this.hammer.on('press', function (event) {
            var node = getNodeFromElement(event.target);
            if (node === NODE_NOT_FOUND) return;
            tree.myDelegate.onTreeNodeRightClick(tree, node, event);
        });
    }

    rootElem.addEventListener('click', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeClick(tree, node, event);
        event.stopPropagation();
        if(!event.target.classList.contains('propertyLink')) {
          event.preventDefault();
        }
    }, false);

    rootElem.addEventListener('dblclick', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeDoubleClick(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('contextmenu', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeRightClick(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('mouseover', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeHover(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('mouseout', function (event) {
        // When the mouse leaves the element, set node to -1 (background), no highlight,
        var node = -1;
        tree.myDelegate.onTreeNodeHover(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);
};

/**
 * Create an HTML element
 * @private
 * @param {HTMLElement} parent - Parent element of the new HTML element
 * @param {string} tagName - New HTML element tag name
 * @param {string=} [className] - New HTML element class
 * @returns {HTMLElement} The newly-created HTML element
 */
Tree.prototype.createHtmlElement_ = function (parent, tagName, className) {
    var elem = document.createElement(tagName);
    parent.appendChild(elem);

    if (className) {
        elem.className = className;
    }

    return elem;
};

/**
 * Iterates through nodes in the tree in pre-order.
 * @param {Object|Number} node - node at which to start the iteration.
 * @param {function(Object, HTMLElement)} callback - callback function for each iterated node.
 */
Tree.prototype.iterate = function (node, callback) {
    if (node &amp;&amp; this.myDelegate.shouldCreateTreeNode(node)) {
        var elem = this.getElementForNode(node);
        if (elem) {
            callback(node, elem);

            var scope = this;
            this.myDelegate.forEachChild(node, function(child) {
                scope.iterate(child, callback);
            });
        }
    }
};

// Alias Tree/TreeDelegate from Private namespace into UI namespace.
// This is temporary and should be removed eventually.
//
avp.TreeDelegate = avu.TreeDelegate = TreeDelegate;
avp.Tree = avu.Tree = Tree;

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Autodesk.Viewing.ApplicationScreenModeDelegate.html">ApplicationScreenModeDelegate</a></li><li><a href="Autodesk.Viewing.Comments.CommentsExtension.html">CommentsExtension</a></li><li><a href="Autodesk.Viewing.Document.html">Document</a></li><li><a href="Autodesk.Viewing.Extension.html">Extension</a></li><li><a href="Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.html">FirstPersonExtension</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.CreateCircle.html">CreateCircle</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.DeleteCircle.html">DeleteCircle</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.EditAction.html">EditAction</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.EditMode.html">EditMode</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.EditModeCircle.html">EditModeCircle</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.Markup.html">Markup</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.MarkupRectangle.html">MarkupRectangle</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.html">MarkupsCore</a></li><li><a href="Autodesk.Viewing.Extensions.Markups.Core.SetCircle.html">SetCircle</a></li><li><a href="Autodesk.Viewing.Extensions.Measure.MeasureExtension.html">MeasureExtension</a></li><li><a href="Autodesk.Viewing.FileLoader.html">FileLoader</a></li><li><a href="Autodesk.Viewing.GuiViewer3D.html">GuiViewer3D</a></li><li><a href="Autodesk.Viewing.HotkeyManager.html">HotkeyManager</a></li><li><a href="Autodesk.Viewing.Initializer.html">Initializer</a></li><li><a href="Autodesk.Viewing.Model.html">Model</a></li><li><a href="Autodesk.Viewing.NullScreenModeDelegate.html">NullScreenModeDelegate</a></li><li><a href="Autodesk.Viewing.Private.Preferences.html">Preferences</a></li><li><a href="Autodesk.Viewing.Private.ViewerState.html">ViewerState</a></li><li><a href="Autodesk.Viewing.ScreenModeDelegate.html">ScreenModeDelegate</a></li><li><a href="Autodesk.Viewing.ToolController.html">ToolController</a></li><li><a href="Autodesk.Viewing.ToolInterface.html">ToolInterface</a></li><li><a href="Autodesk.Viewing.UI.Button.html">Button</a></li><li><a href="Autodesk.Viewing.UI.ComboButton.html">ComboButton</a></li><li><a href="Autodesk.Viewing.UI.Control.html">Control</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html">ControlGroup</a></li><li><a href="Autodesk.Viewing.UI.DockingPanel.html">DockingPanel</a></li><li><a href="Autodesk.Viewing.UI.ObjectContextMenu.html">ObjectContextMenu</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html">RadioButtonGroup</a></li><li><a href="Autodesk.Viewing.UI.SettingsPanel.html">SettingsPanel</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html">ToolBar</a></li><li><a href="Autodesk.Viewing.Viewer3D.html">Viewer3D</a></li><li><a href="Autodesk.Viewing.ViewingApplication.html">ViewingApplication</a></li><li><a href="Autodesk.Viewing.ViewingUtilities.html">ViewingUtilities</a></li></ul><h3>Events</h3><ul><li><a href="Autodesk.Viewing.UI.Button.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.Button.html#event:STATE_CHANGED">STATE_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.Button.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ComboButton.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ComboButton.html#event:STATE_CHANGED">STATE_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ComboButton.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.Control.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.Control.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html#event:CONTROL_ADDED">CONTROL_ADDED</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html#event:CONTROL_REMOVED">CONTROL_REMOVED</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html#event:SIZE_CHANGED">SIZE_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ControlGroup.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:ACTIVE_BUTTON_CHANGED">ACTIVE_BUTTON_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:CONTROL_ADDED">CONTROL_ADDED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:CONTROL_REMOVED">CONTROL_REMOVED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:SIZE_CHANGED">SIZE_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.RadioButtonGroup.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html#event:COLLAPSED_CHANGED">COLLAPSED_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html#event:CONTROL_ADDED">CONTROL_ADDED</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html#event:CONTROL_REMOVED">CONTROL_REMOVED</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html#event:SIZE_CHANGED">SIZE_CHANGED</a></li><li><a href="Autodesk.Viewing.UI.ToolBar.html#event:VISIBILITY_CHANGED">VISIBILITY_CHANGED</a></li></ul><h3>Tutorials</h3><ul><li>feature_markup</li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha11</a> on Fri Apr 15 2016 17:19:51 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
